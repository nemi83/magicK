# Client Database v2
#
# Author: NEMi
# Description:  Client database is an application that stores client data and manages appointments and reports.
#               When run, a list of upcoming client appointments is displayed in table view. Next to the table, user
#               can browse trough different dates and see who was and is scheduled for evaluation. On the dashboard
#               tab, user can add a client and appointment or search for a specific client in the list all clients tab.
#               When a client is doubleclicked, client information and a list of reports are displayed in 2 subsequent
#               tabs. On client info tab, the user can add reports or edits initial client data.
# WARNING:  Any manual changes made to this file will be lost and the application may break.
#           Do not edit this file unless you know what you are doing!

import sqlite3
from datetime import datetime
from PyQt5 import QtCore, QtGui, QtWidgets

path = 'path/to/database/clients.db'

class ClientInputDialog(QtWidgets.QDialog):
    def __init__(self, clientID, status, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Dodaj klienta")
        self.setFixedWidth(450)
        self.status = status
        self.setWindowTitle("Dodaj klienta" if status == "add" else "Popravi klienta")
        self.setFixedWidth(450)
        self.clientID = clientID
        self.status = status
        layout = QtWidgets.QVBoxLayout()
        self.name_label = QtWidgets.QLabel("Ime:")
        self.name_input = QtWidgets.QLineEdit(self)
        self.lastname_label = QtWidgets.QLabel("Priimek:")
        self.lastname_input = QtWidgets.QLineEdit(self)
        self.street_label = QtWidgets.QLabel("Naslov:")
        self.street_input = QtWidgets.QLineEdit(self)
        self.zip_label = QtWidgets.QLabel("Poštna številka:")
        self.zip_input = QtWidgets.QLineEdit(self)
        self.city_label = QtWidgets.QLabel("Pošta:")
        self.city_input = QtWidgets.QLineEdit(self)
        self.dob_label = QtWidgets.QLabel("Datum rojstva:")
        self.dob_input = QtWidgets.QLineEdit(self)
        self.email_label = QtWidgets.QLabel("E-mail:")
        self.email_input = QtWidgets.QLineEdit(self)
        self.phone_label = QtWidgets.QLabel("Telefon:")
        self.phone_input = QtWidgets.QLineEdit(self)
        self.diagnosis_label = QtWidgets.QLabel("Diagnoza:")
        self.diagnosis_input = QtWidgets.QLineEdit(self)
        self.amnesa_label = QtWidgets.QLabel("Začetna amneza:")
        self.amnesa_input = QtWidgets.QLineEdit(self)

        if self.status == "add":
            self.add_button = QtWidgets.QPushButton("Dodaj klienta", self)
        elif self.status == "edit":
            self.add_button = QtWidgets.QPushButton("Popravi podatke", self)

        self.add_button.clicked.connect(self.add_or_update_client)

        layout.addWidget(self.name_label)
        layout.addWidget(self.name_input)
        layout.addWidget(self.lastname_label)
        layout.addWidget(self.lastname_input)
        layout.addWidget(self.street_label)
        layout.addWidget(self.street_input)
        layout.addWidget(self.zip_label)
        layout.addWidget(self.zip_input)
        layout.addWidget(self.city_label)
        layout.addWidget(self.city_input)
        layout.addWidget(self.dob_label)
        layout.addWidget(self.dob_input)
        layout.addWidget(self.email_label)
        layout.addWidget(self.email_input)
        layout.addWidget(self.phone_label)
        layout.addWidget(self.phone_input)
        layout.addWidget(self.diagnosis_label)
        layout.addWidget(self.diagnosis_input)
        layout.addWidget(self.amnesa_label)
        layout.addWidget(self.amnesa_input)
        layout.addWidget(self.add_button)
        self.setLayout(layout)
        if self.status == "edit":
            self.populate_fields()
    def populate_fields(self):
        client_data = self.fetch_client_data_from_database()
        self.name_input.setText(client_data['clientName'])
        self.lastname_input.setText(client_data['clientLastname'])
        self.street_input.setText(client_data['clientStreet'])
        self.zip_input.setText(str(client_data['clientZip']))
        self.city_input.setText(client_data['clientCity'])
        self.dob_input.setText(client_data['clientDOB'])
        self.email_input.setText(client_data['clientEmail'])
        self.phone_input.setText(client_data['clientMobile'])
        self.diagnosis_input.setText(client_data['clientDiagnosis'])
        self.amnesa_input.setText(client_data['clientAmnesia'])
    def fetch_client_data_from_database(self):
        # Connect to your database and fetch the client data based on the client_id
        conn = sqlite3.connect(path)
        cursor = conn.cursor()
        # Assuming you have a clients table with the following columns: clientID, clientName, clientLastname, etc.
        query = "SELECT * FROM client_info WHERE clientID = ?"
        cursor.execute(query, (self.clientID,))
        client_data = cursor.fetchone()
        # Close the database connection
        conn.close()
        # Return the client data as a dictionary
        return {
            'clientName': client_data[1],
            'clientLastname': client_data[2],
            'clientStreet': client_data[3],
            'clientZip': client_data[4],
            'clientCity': client_data[5],
            'clientDOB': client_data[6],
            'clientEmail': client_data[8],
            'clientMobile': client_data[9],
            'clientDiagnosis': client_data[10],
            'clientAmnesia': client_data[11]
        }
    def add_or_update_client(self):
        if self.status == "add":
            self.add_client()
        elif self.status == "edit":
            self.edit_client()
        self.accept()
    def add_client(self):
        name = self.name_input.text()
        lastname = self.lastname_input.text()
        street = self.street_input.text()
        zip1 = self.zip_input.text()
        city = self.city_input.text()
        dob = self.dob_input.text()
        email = self.email_input.text()
        phone = self.phone_input.text()
        diagnosis = self.diagnosis_input.text()
        amnesa = self.amnesa_input.text()
        if name and lastname and street and zip1 and city and dob and email and phone and diagnosis and amnesa:
            conn = sqlite3.connect(path)
            cursor = conn.cursor()

            query = ("INSERT INTO client_info (clientName, clientLastName, clientStreet, clientZip, clientCity, "
                    "clientDob, clientEmail, clientMobile, clientDiagnosis, clientAmnesia)"
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")
            cursor.execute(query, (name, lastname, street, zip1, city, dob, email, phone, diagnosis, amnesa))
            conn.commit()
            conn.close()
            QtWidgets.QMessageBox.information(self, "Success", f"Klient '{name}' dodan v bazo!")
            self.accept()
        else:
            QtWidgets.QMessageBox.warning(self.parent(), "Error", "Vpisati je potrebno vse podatke klienta")

    def edit_client(self):
        name = self.name_input.text()
        lastname = self.lastname_input.text()
        street = self.street_input.text()
        zip1 = self.zip_input.text()
        city = self.city_input.text()
        dob = self.dob_input.text()
        email = self.email_input.text()
        phone = self.phone_input.text()
        diagnosis = self.diagnosis_input.text()
        amnesa = self.amnesa_input.text()

        if name and lastname and street and zip1 and city and dob and email and phone and diagnosis and amnesa:
            conn = sqlite3.connect(path)
            cursor = conn.cursor()
            # Assuming you have a unique identifier for the client, e.g., clientID
            query = ("UPDATE client_info SET clientName=?, clientLastName=?, clientStreet=?, clientZip=?, "
                     "clientCity=?, clientDob=?, clientEmail=?, clientMobile=?, clientDiagnosis=?, clientAmnesia=? "
                     "WHERE clientID=?")
            cursor.execute(query, (name, lastname, street, zip1, city, dob, email, phone,
                                   diagnosis, amnesa, self.clientID))
            conn.commit()
            conn.close()
            QtWidgets.QMessageBox.information(self, "Success", f"Klient '{name}' uspešno popravljen!")
            self.accept()
            #self.clientAdded.emit()
        else:
            QtWidgets.QMessageBox.warning(self, "Error", "Vpisati je potrebno vse podatke klienta")
class AddAppointmentDialog(QtWidgets.QDialog):
    def __init__(self, selected_date_str, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Dodaj obisk")
        self.setFixedWidth(450)
        self.selected_date_str = selected_date_str
        self.clientComboBox = QtWidgets.QComboBox(self)
        self.populate_client_combo_box()  # Populate the clientComboBox with client names

        self.timeLineEdit = QtWidgets.QLineEdit(self)
        self.timeLineEdit.setPlaceholderText("Vnesi uro obiska (HH:MM)")

        self.addButton = QtWidgets.QPushButton("Dodaj obisk", self)
        self.addButton.clicked.connect(self.add_appointment)

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(QtWidgets.QLabel(f"Izbran datum: {self.selected_date_str}", self))
        layout.addWidget(self.clientComboBox)
        layout.addWidget(self.timeLineEdit)
        layout.addWidget(self.addButton)
        self.setLayout(layout)
    def validate_time_format(self, time_text):
        try:
            # Attempt to parse the time
            time_components = time_text.split(":")
            if len(time_components) != 2:
                return False
            hours = int(time_components[0])
            minutes = int(time_components[1])

            # Check if hours and minutes are within valid ranges
            if not (0 <= hours <= 23) or not (0 <= minutes <= 59):
                return False
            return True
        except ValueError:
            return False
    def is_time_slot_available(self, client_id, selected_date_str, time_text):
        conn = sqlite3.connect(path)
        cursor = conn.cursor()
        # Check if the time slot is already taken for the selected date
        query = "SELECT COUNT(*) FROM client_appointment WHERE appointmentDate = ? AND appointmentTime = ?"
        cursor.execute(query, (selected_date_str, time_text))
        count = cursor.fetchone()[0]
        conn.close()

        return count == 0
    def add_appointment(self):
        selected_client_id = self.get_selected_client_id()
        time_text = self.timeLineEdit.text()

        if not self.validate_time_format(time_text):
            QtWidgets.QMessageBox.warning(self, "Napačen format zapisa ure",
                                          "Prosim, zapišite uro v formatu HH:MM.")
            return

        if not self.is_time_slot_available(selected_client_id, self.selected_date_str, time_text):
            QtWidgets.QMessageBox.warning(self, "Ura za izbrani dan je že zasedena", "Prosim izberite drugo uro.")
            return

        if selected_client_id and time_text:
            conn = sqlite3.connect(path)
            cursor = conn.cursor()
            # Insert the appointment into the appointments table
            query = "INSERT INTO client_appointment (clientID, appointmentDate, appointmentTime) VALUES (?, ?, ?)"
            cursor.execute(query, (selected_client_id, self.selected_date_str, time_text))
            conn.commit()
            conn.close()
            self.accept()
    def populate_client_combo_box(self):
        conn = sqlite3.connect(path)
        cursor = conn.cursor()
        # Fetch client names from the database
        query = "SELECT clientID, clientName, clientLastName FROM client_info"
        cursor.execute(query)
        client_data = cursor.fetchall()
        conn.close()

        for client_id, client_name, client_last_name in client_data:
            self.clientComboBox.addItem(f"{client_name}, {client_last_name} (ID: {client_id})", userData=client_id)
    def get_selected_client_id(self):
        selected_index = self.clientComboBox.currentIndex()
        if selected_index >= 0:
            return self.clientComboBox.itemData(selected_index)
        else:
            return None
class ClientReportDialog(QtWidgets.QDialog):
    def __init__(self, clientID, clientName, clientLastname, reportDate, mode, parent=None):
        super().__init__(parent)
        self.clientID = clientID
        self.selectDate = reportDate
        self.mode = mode
        self.setWindowTitle("Dodaj Izvid")
        self.setFixedWidth(450)

        layout = QtWidgets.QVBoxLayout()
        self.clientName_label = QtWidgets.QLabel(f"Ime klienta: {clientName}", self)
        self.clientLastname_label = QtWidgets.QLabel(f"Priimek klienta: {clientLastname}", self)
        self.reportDate_label = QtWidgets.QLabel(f"Datum obiska: {reportDate}", self)
        self.reportText_input = QtWidgets.QTextEdit(self)
        # Create either "Add Report" or "Update Report" button based on the mode
        if self.mode == "add":
            self.reportReport_button = QtWidgets.QPushButton("Dodaj izvid", self)
        elif self.mode == "edit":
            self.reportReport_button = QtWidgets.QPushButton("Posodobi izvid", self)

        self.reportReport_button.clicked.connect(self.add_or_update_report)

        layout.addWidget(self.clientName_label)
        layout.addWidget(self.clientLastname_label)
        layout.addWidget(self.reportDate_label)
        layout.addWidget(self.reportText_input)
        layout.addWidget(self.reportReport_button)
        self.setLayout(layout)
    def add_or_update_report(self):
        report_text = self.reportText_input.toPlainText()
        if self.mode == "add":
            self.add_report()
        elif self.mode == "edit":
            self.edit_report()
        self.accept()
    def add_report(self):
        reportText = self.reportText_input.toPlainText()

        if reportText:
            if reportText:
                # Check if a report for the same client and date already exists
                conn = sqlite3.connect(path)
                cursor = conn.cursor()

                check_query = "SELECT reportID FROM client_report WHERE clientID = ? AND reportDate = ?"
                cursor.execute(check_query, (self.clientID, self.selectDate))
                existing_report = cursor.fetchone()

                if existing_report is None:
                    # Report does not exist for the specified date, insert it
                    report_query = "INSERT INTO client_report (clientID, reportDate, reportReport) VALUES (?, ?, ?)"
                    cursor.execute(report_query, (self.clientID, self.selectDate, reportText))
                    report_id = cursor.lastrowid  # Get the ID of the newly inserted report
                    conn.commit()
                    # Update the corresponding row in the client_appointment table with the report ID
                    appointment_query = "UPDATE client_appointment SET reportID = ? WHERE clientID = ? AND appointmentDate = ?"
                    cursor.execute(appointment_query, (report_id, self.clientID, self.selectDate))
                    conn.commit()
                    conn.close()
                    self.accept()
                else:
                    # A report already exists for the specified date, notify the user
                    QtWidgets.QMessageBox.warning(self, "Opozorilo", "Izvid za ta datum že obstaja.")
    def edit_report(self):
        reportText = self.reportText_input.toPlainText()

        if reportText:
            if reportText:
                # Check if a report for the same client and date already exists
                conn = sqlite3.connect(path)
                cursor = conn.cursor()

                check_query = "SELECT reportID FROM client_report WHERE clientID = ? AND reportDate = ?"
                cursor.execute(check_query, (self.clientID, self.selectDate))
                existing_report = cursor.fetchone()

                if existing_report is not None:
                    update_query = "UPDATE client_report SET reportReport = ? WHERE clientID = ? AND reportDate = ?"
                    cursor.execute(update_query, (reportText, self.clientID, self.selectDate))
                    conn.commit()
                    conn.close()
                    self.accept()
                    QtWidgets.QMessageBox.warning(self, "Opomnik", "Izvid za ta datum je popravljen.")
class AmnesiaCorrectionDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Amneza popravek")

        self.amnesia_text_edit = QtWidgets.QTextEdit()
        self.correct_button = QtWidgets.QPushButton("Popravi")

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.amnesia_text_edit)
        layout.addWidget(self.correct_button)

        self.setLayout(layout)
        self.correct_button.clicked.connect(self.accept)
    def get_corrected_amnesia(self):
        return self.amnesia_text_edit.toPlainText()
class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        self.marked_dates = set()
        self.selectedDate = None
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        # create tab widget framework
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        self.tabWidget.setGeometry(QtCore.QRect(10, 10, 781, 541))
        self.tabWidget.setTabShape(QtWidgets.QTabWidget.Triangular)
        self.tabWidget.setObjectName("tabWidget")
        # create main tab Dashboard for client and appointment overview with functionality
        self.dashboard = QtWidgets.QWidget()
        self.dashboard.setObjectName("dashboard")
        self.clientAppointments = QtWidgets.QTableView(self.dashboard)
        self.clientAppointments.setGeometry(QtCore.QRect(10, 20, 351, 241))
        self.clientAppointments.setObjectName("clientAppointments")
        self.initialize_client_appointments_table()
        self.clientAppointments.doubleClicked.connect(self.client_row_double_clicked)
        self.findClient = QtWidgets.QPushButton(self.dashboard)
        self.findClient.setGeometry(QtCore.QRect(10, 420, 251, 31))
        self.findClient.setObjectName("findClient")
        self.findClient.clicked.connect(self.open_client_list_tab)
        self.calendarWidget_2 = QtWidgets.QCalendarWidget(self.dashboard)
        self.calendarWidget_2.setGeometry(QtCore.QRect(370, 20, 392, 240))
        self.calendarWidget_2.setObjectName("calendarWidget_2")
        self.calendarWidget_2.clicked[QtCore.QDate].connect(self.display_appointments_for_selected_date)
        self.addClient = QtWidgets.QPushButton(self.dashboard)
        self.addClient.setGeometry(QtCore.QRect(10, 340, 251, 34))
        self.addClient.setObjectName("addClient")
        self.addClient.clicked.connect(lambda: self.open_client_dialog(None, "add"))
        self.addAppointment = QtWidgets.QPushButton(self.dashboard)
        self.addAppointment.setGeometry(QtCore.QRect(10, 380, 251, 34))
        self.addAppointment.setObjectName("addAppointment")
        self.addAppointment.clicked.connect(self.open_add_appointment_dialog)
        self.tabWidget.addTab(self.dashboard, "")
        # create tab Client list for client list overview and functionality
        self.client_list = QtWidgets.QWidget()
        self.client_list.setObjectName("client_list")
        self.clientListAll = QtWidgets.QTableWidget(self.client_list)
        self.clientListAll.setGeometry(QtCore.QRect(10, 110, 751, 391))
        self.clientListAll.setObjectName("clientListAll")
        self.clientListAll.doubleClicked.connect(self.client_row_double_clicked)
        self.initialize_client_list_table()
        self.plainTextEdit = QtWidgets.QPlainTextEdit(self.client_list)
        self.plainTextEdit.setGeometry(QtCore.QRect(10, 70, 41, 31))
        self.plainTextEdit.setObjectName("plainTextEdit")
        self.findClient2 = QtWidgets.QLineEdit(self.client_list)
        self.findClient2.setGeometry(QtCore.QRect(10, 20, 151, 32))
        self.findClient2.setObjectName("findClient2")
        self.findClient2.textChanged.connect(self.update_search_results)
        self.visit = QtWidgets.QPushButton(self.client_list)
        self.visit.setGeometry(QtCore.QRect(60, 70, 51, 34))
        self.visit.setObjectName("visit")
        self.status = QtWidgets.QPushButton(self.client_list)
        self.status.setGeometry(QtCore.QRect(120, 70, 51, 34))
        self.status.setObjectName("status")
        self.diagnosis = QtWidgets.QPushButton(self.client_list)
        self.diagnosis.setGeometry(QtCore.QRect(180, 70, 71, 34))
        self.diagnosis.setObjectName("diagnosis")
        self.tabWidget.addTab(self.client_list, "")
        # create tab Client for client overview and functionality
        self.client = QtWidgets.QWidget()
        self.client.setObjectName("client")
        self.plainTextEdit_2 = QtWidgets.QPlainTextEdit(self.client)
        self.plainTextEdit_2.setGeometry(QtCore.QRect(10, 0, 111, 31))
        self.plainTextEdit_2.setObjectName("plainTextEdit_2")
        self.tableWidget = QtWidgets.QTableWidget(self.client)
        self.tableWidget.setGeometry(QtCore.QRect(10, 40, 351, 241))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        self.tabWidget.currentChanged.connect(self.update_client_info)
        self.calendarWidget = QtWidgets.QCalendarWidget(self.client)
        self.calendarWidget.setGeometry(QtCore.QRect(380, 40, 392, 240))
        self.calendarWidget.setObjectName("calendarWidget")
        self.calendarWidget.clicked[QtCore.QDate].connect(self.store_selected_date)
        self.calendarWidget.clicked.connect(self.display_report_for_selected_date)
        self.plainTextEdit_3 = QtWidgets.QPlainTextEdit(self.client)
        self.plainTextEdit_3.setGeometry(QtCore.QRect(10, 290, 131, 31))
        self.plainTextEdit_3.setObjectName("plainTextEdit_3")
        self.amneza = QtWidgets.QLabel(self.client)
        self.amneza.setGeometry(QtCore.QRect(10, 330, 751, 41))
        self.amneza.setObjectName("amneza")
        self.plainTextEdit_4 = QtWidgets.QPlainTextEdit(self.client)
        self.plainTextEdit_4.setGeometry(QtCore.QRect(10, 380, 131, 31))
        self.plainTextEdit_4.setObjectName("plainTextEdit_4")
        self.report = QtWidgets.QLabel(self.client)
        self.report.setGeometry(QtCore.QRect(10, 420, 741, 71))
        self.report.setObjectName("report")
        self.report.setWordWrap(True)
        self.editClient = QtWidgets.QPushButton(self.client)
        self.editClient.setGeometry(QtCore.QRect(290, 0, 61, 34))
        self.editClient.setObjectName("editClient")
        self.editClient.clicked.connect(lambda: self.open_client_dialog(self.currentClientID, "edit"))
        self.editAmneza = QtWidgets.QPushButton(self.client)
        self.editAmneza.setGeometry(QtCore.QRect(290, 290, 61, 34))
        self.editAmneza.setObjectName("editAmneza")
        self.editAmneza.clicked.connect(self.open_correction_amnesia)
        self.addReport = QtWidgets.QPushButton(self.client)
        self.addReport.setGeometry(QtCore.QRect(240, 380, 51, 34))
        self.addReport.setObjectName("addReport")
        self.addReport.clicked.connect(lambda: self.open_report_dialog(
        self.currentClientID, self.currentClientName, self.currentClientLastname, self.selectedDate, "add"))
        self.editReport = QtWidgets.QPushButton(self.client)
        self.editReport.setGeometry(QtCore.QRect(300, 380, 61, 34))
        self.editReport.setObjectName("editReport")
        self.editReport.clicked.connect(lambda: self.open_report_dialog(
            self.currentClientID, self.currentClientName, self.currentClientLastname, self.selectedDate, "edit"))
        self.firstVisit = QtWidgets.QPlainTextEdit(self.client)
        self.firstVisit.setObjectName(u"firstVisit")
        self.firstVisit.setGeometry(QtCore.QRect(380, 290, 101, 31))
        self.dateVisit = QtWidgets.QLabel(self.client)
        self.dateVisit.setObjectName(u"dateVisit")
        self.dateVisit.setGeometry(QtCore.QRect(490, 290, 81, 31))
        self.numVisits = QtWidgets.QPlainTextEdit(self.client)
        self.numVisits.setObjectName(u"numVisits")
        self.numVisits.setGeometry(QtCore.QRect(570, 290, 111, 31))
        self.numVisits_2 = QtWidgets.QLabel(self.client)
        self.numVisits_2.setObjectName(u"numVisits_2")
        self.numVisits_2.setGeometry(QtCore.QRect(690, 290, 71, 31))
        self.tabWidget.addTab(self.client, "")
        # create tab allReports
        self.allReports = QtWidgets.QWidget()
        self.allReports.setObjectName(u"allReports")
        self.clientName = QtWidgets.QPlainTextEdit(self.allReports)
        self.clientName.setObjectName(u"clientName")
        self.clientName.setGeometry(QtCore.QRect(10, 20, 141, 31))
        self.clientText = QtWidgets.QLabel(self.allReports)
        self.clientText.setObjectName(u"clientText")
        self.clientText.setGeometry(QtCore.QRect(170, 20, 201, 31))
        self.allReportsList = QtWidgets.QTableWidget(self.allReports)
        self.allReportsList.setObjectName(u"allReportsList")
        self.allReportsList.setGeometry(QtCore.QRect(10, 60, 751, 441))
        self.tabWidget.addTab(self.allReports, "")
        # Connect the currentChanged signal of tabWidget to a slot function
        self.tabWidget.currentChanged.connect(self.on_tab_changed)
        self.tabWidget.currentChanged.connect(self.on_tab_changed)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 30))
        self.menubar.setObjectName("menubar")
        self.menuMenu = QtWidgets.QMenu(self.menubar)
        self.menuMenu.setObjectName("menuMenu")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.menubar.addAction(self.menuMenu.menuAction())
        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    # Function where all the text names are given to GUI
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.findClient.setText(_translate("MainWindow", "Išči klienta...."))
        self.addClient.setText(_translate("MainWindow", "Dodaj Klienta"))
        self.addAppointment.setText(_translate("MainWindow", "Dodaj obisk"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.dashboard), _translate("MainWindow", "Dashboard"))
        self.plainTextEdit.setPlainText(_translate("MainWindow", "Filtri"))
        self.findClient2.setText(_translate("MainWindow", ""))
        self.visit.setText(_translate("MainWindow", "Obisk"))
        self.status.setText(_translate("MainWindow", "Status"))
        self.diagnosis.setText(_translate("MainWindow", "Diagnoza"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.client_list), _translate("MainWindow", "Client List"))
        self.plainTextEdit_2.setPlainText(_translate("MainWindow", "Osebni podatki"))
        self.plainTextEdit_3.setPlainText(_translate("MainWindow", "Začetna amneza"))
        self.amneza.setText(_translate("MainWindow", "TextLabel"))
        self.plainTextEdit_4.setPlainText(_translate("MainWindow", "Izvid"))
        self.report.setText(_translate("MainWindow", "TextLabel"))
        self.editClient.setText(_translate("MainWindow", "Popravi"))
        self.editAmneza.setText(_translate("MainWindow", "Popravi"))
        self.addReport.setText(_translate("MainWindow", "Dodaj"))
        self.editReport.setText(_translate("MainWindow", "Popravi"))
        self.firstVisit.setPlainText(_translate("MainWindow", u"Prvi obisk:", None))
        self.dateVisit.setText(_translate("MainWindow", u"date", None))
        self.numVisits.setPlainText(_translate("MainWindow", u"\u0160tevilo obiskov:", None))
        self.numVisits_2.setText(_translate("MainWindow", u"number", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.client), _translate("MainWindow", "Client Info"))
        self.clientName.setPlainText(_translate("MainWindow", u"Ime in priimek", None))
        self.clientText.setText(_translate("MainWindow", u"TextLabel", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.allReports),
                                  _translate("MainWindow", u"All Reports", None))
        self.menuMenu.setTitle(_translate("MainWindow", "Menu"))
    def open_client_list_tab(self):
        self.tabWidget.setCurrentIndex(1)
        self.findClient2.setFocus()
    def open_correction_amnesia(self):
        correction_dialog = AmnesiaCorrectionDialog()
        if correction_dialog.exec_() == QtWidgets.QDialog.Accepted:
            corrected_amnesia = correction_dialog.get_corrected_amnesia()
            self.amneza.setText(corrected_amnesia)
            self.update_amnesia_in_database(corrected_amnesia)
    def update_amnesia_in_database(self, corrected_amnesia):
        conn = sqlite3.connect(path)
        cursor = conn.cursor()

        # Update the amnesia field for the specified client ID
        cursor.execute("UPDATE client_info SET clientAmnesia = ? WHERE clientID = ?",
                       (corrected_amnesia, self.currentClientID))
        conn.commit()
        conn.close()
    def initialize_client_list_table(self):
        # Fetch and populate data for the client list table
        conn = sqlite3.connect(path)
        cursor = conn.cursor()

        # Fetch client data from the database
        query = "SELECT clientID, clientName, clientLastname, clientDiagnosis FROM client_info"
        cursor.execute(query)
        client_data = cursor.fetchall()

        conn.close()

        self.clientListAll.setColumnCount(4)
        self.clientListAll.setHorizontalHeaderLabels(["ID", "Ime", "Priimek", "Diagnoza"])
        self.clientListAll.setRowCount(len(client_data))

        for row_idx, row_data in enumerate(client_data):
            for col_idx, value in enumerate(row_data):
                item = QtWidgets.QTableWidgetItem(str(value))
                self.clientListAll.setItem(row_idx, col_idx, item)
    def initialize_client_appointments_table(self):
        # Fetch appointment data from the database and join it with client data
        connection = sqlite3.connect(path)
        cursor = connection.cursor()
        cursor.execute(
            "SELECT client_info.clientID, client_info.clientName, client_info.clientLastName, "
            "client_appointment.appointmentDate, "
            "client_appointment.appointmentTime FROM client_info INNER JOIN client_appointment ON "
            "client_info.clientID = client_appointment.clientID")
        appointments_data = cursor.fetchall()
        connection.close()
        # Sort the appointments by date and time
        appointments_data.sort(key=lambda x: datetime.strptime(x[3] + " " + x[4], "%Y-%m-%d %H:%M"))
        # Filter and select only the next 5 upcoming appointments
        current_datetime = datetime.now()
        next_upcoming_appointments = []
        for client_id, client_name, client_last_name, appointment_date_str, appointment_time_str in appointments_data:
            appointment_datetime = datetime.strptime(appointment_date_str + " " + appointment_time_str,
                                                     "%Y-%m-%d %H:%M")
            if appointment_datetime >= current_datetime and len(next_upcoming_appointments) < 8:
                next_upcoming_appointments.append(
                    (client_id, client_name, client_last_name, appointment_date_str, appointment_time_str))
        # Populate the QTableView with the filtered next upcoming appointments
        self.populate_next_upcoming_appointments(next_upcoming_appointments)
    def on_tab_changed(self, index):
        # Check if the "Client List" tab is clicked (assuming it's the second tab, adjust index accordingly)
        if index == 1:
            # Retrieve new data from the database and update the client list table
            self.initialize_client_list_table()
        elif index == 0:
            self.initialize_client_appointments_table()
    def store_selected_date(self, selected_date):
        self.selectedDate = selected_date.toString("yyyy-MM-dd")
    def display_appointments_for_selected_date(self, selected_date):
        #self.selectedDate = selected_date
        # Fetch appointment data for the selected date from the database
        connection = sqlite3.connect(path)
        cursor = connection.cursor()
        selected_date_str = selected_date.toString(QtCore.Qt.ISODate)
        cursor.execute('SELECT client_info.clientID, client_info.clientName, client_info.clientLastName, '
                       'client_appointment.appointmentDate, '
                       'client_appointment.appointmentTime FROM client_info INNER JOIN client_appointment ON '
                       'client_info.clientID = client_appointment.clientID WHERE appointmentDate=?',
                       (selected_date_str,))
        appointments_data = cursor.fetchall()
        connection.close()
        # Populate the QTableView with the fetched appointments
        self.populate_next_upcoming_appointments(appointments_data)
    def populate_next_upcoming_appointments(self, appointments):
        model = QtGui.QStandardItemModel(len(appointments), 5)
        model.setHorizontalHeaderLabels(["ID", "Ime", "Priimek", "Datum obiska", "Ura"])

        for row, (client_id, client_name, client_last_name, appointment_date_str, appointment_time_str) in enumerate(appointments):
            client_id_item = QtGui.QStandardItem()
            client_id_item.setData(client_id, QtCore.Qt.DisplayRole)
            client_name_item = QtGui.QStandardItem(client_name)
            client_last_name_item = QtGui.QStandardItem(client_last_name)
            appointment_date_item = QtGui.QStandardItem(appointment_date_str)
            appointment_time_item = QtGui.QStandardItem(appointment_time_str)

            model.setItem(row, 0, client_id_item)
            model.setItem(row, 1, client_name_item)
            model.setItem(row, 2, client_last_name_item)
            model.setItem(row, 3, appointment_date_item)
            model.setItem(row, 4, appointment_time_item)

        self.clientAppointments.setModel(model)
        self.clientAppointments.setColumnWidth(0, 5)
        self.clientAppointments.setColumnWidth(1, 80)
        self.clientAppointments.setColumnWidth(2, 80)
        self.clientAppointments.setColumnWidth(3, 83)
        self.clientAppointments.setColumnWidth(4, 55)
    def open_client_dialog(self, clientID, mode):
        dialog = ClientInputDialog(clientID, mode)
        dialog.exec_()
    def open_add_appointment_dialog(self):
        selected_date = self.calendarWidget_2.selectedDate()
        selected_date_str = selected_date.toString(QtCore.Qt.ISODate)
        dialog = AddAppointmentDialog(selected_date_str)
        dialog.exec_()
    def open_report_dialog(self, clientID, clientName, clientLastname, reportDate, mode):
        dialog = ClientReportDialog(clientID, clientName, clientLastname, reportDate, mode)
        dialog.exec_()
    def update_search_results(self, search_text):
        conn = sqlite3.connect(path)
        cursor = conn.cursor()
        # Fetch client data from the database based on the search_text
        if search_text:
            query = (f"SELECT clientID, clientName, clientLastname, clientDiagnosis FROM client_info"
                     f" WHERE clientName LIKE ? OR clientLastname LIKE ?")
            cursor.execute(query, ('%' + search_text + '%', '%' + search_text + '%'))
        else:
            query = "SELECT clientID, clientName, clientLastname, clientDiagnosis FROM client_info"
            cursor.execute(query)
        client_data = cursor.fetchall()
        conn.close()

        self.clientListAll.setRowCount(len(client_data))

        for row_idx, row_data in enumerate(client_data):
            for col_idx, value in enumerate(row_data):
                item = QtWidgets.QTableWidgetItem(str(value))
                self.clientListAll.setItem(row_idx, col_idx, item)
    def update_client_info(self, tab_index):
        if tab_index == 1:  # Assuming the Client Info tab is at index 1
            client_id = self.get_selected_client_id()  # Implement this function to get the selected client's ID
            if client_id:
                self.populate_client_info_table(client_id)
    def get_selected_client_id(self):
        selected_row = self.clientListAll.currentRow()
        client_id_item = self.clientListAll.item(selected_row, 0)  # Assuming the ID is in the first column

        if client_id_item is not None:
            return int(client_id_item.text())
        else:
            return None
    def client_row_double_clicked(self, item):
        client_id_index = item.sibling(item.row(), 0)
        client_id_item = client_id_index.data(QtCore.Qt.DisplayRole)

        if client_id_item is not None:
            #client_id_text = client_id_item.text()  # Get the text from the cell
            try:
                client_id = int(client_id_item)  # Convert to integer
                self.tabWidget.setCurrentIndex(2)  # Switch to the Client Info tab
                self.populate_client_info_table(client_id)
                self.populate_client_report_table(client_id)
            except ValueError:
                print("Invalid client ID:", client_id_item)
    def populate_client_report_table(self, client_id):
        conn = sqlite3.connect(path)
        cursorName = conn.cursor()
        cursorReport = conn.cursor()
        # Fetch client name the database
        query = ("SELECT clientName, clientLastname FROM client_info WHERE clientID = ?")
        cursorName.execute(query, (client_id,))
        client_name = cursorName.fetchone()
        # Fetch all reports from the database
        query = "SELECT reportDate, reportReport FROM client_report WHERE clientID = ? ORDER BY reportDate DESC "
        cursorReport.execute(query, (client_id,))
        all_reports = cursorReport.fetchall()
        conn.close()
        full_name = f"{client_name[0]} {client_name[1]}"
        self.clientText.clear()
        self.clientText.setText(str(full_name))
        self.allReportsList.clear()
        self.allReportsList.setRowCount(len(all_reports))
        self.allReportsList.setColumnCount(2)
        self.allReportsList.setColumnWidth(1, 640)
        self.allReportsList.setHorizontalHeaderLabels(['Datum obiska', 'Izvidi'])
        # Minimum row height for each row
        min_row_height = 50
        for row, all_report in enumerate(all_reports):
            report_date, report_text = all_report
            self.allReportsList.setItem(row, 0, QtWidgets.QTableWidgetItem(str(report_date)))
            self.allReportsList.setItem(row, 1, QtWidgets.QTableWidgetItem(report_text))
            calculated_height = len(report_text) // 50 * 20  # Adjust the divisor (50) and multiplier (20) as needed
            row_height = max(calculated_height, min_row_height)
            self.allReportsList.setRowHeight(row, row_height)
    def populate_client_info_table(self, client_id):
        conn = sqlite3.connect(path)
        cursorData = conn.cursor()
        cursorAmneza = conn.cursor()
        cursorReport = conn.cursor()
        cursorCal = conn.cursor()
        # Fetch client data from the database based on the client_id
        query = ("SELECT clientName, clientLastname, clientStreet, clientZip, clientCity, "
                 "clientDOB, clientEmail, clientMobile, clientDiagnosis"
                 " FROM client_info WHERE clientID = ?")
        cursorData.execute(query, (client_id,))
        client_data = cursorData.fetchone()

        queryAmnesa = ("SELECT clientAmnesia"
                       " FROM client_info WHERE clientID = ?")
        cursorAmneza.execute(queryAmnesa, (client_id,))
        amneza_value = cursorAmneza.fetchone()[0]

        # Fetch the last report for the client from the database
        query = "SELECT reportDate, reportReport FROM client_report WHERE clientID = ? ORDER BY reportDate DESC LIMIT 1"
        cursorReport.execute(query, (client_id,))
        last_report = cursorReport.fetchone()

        query = "SELECT appointmentDate FROM client_appointment WHERE clientID = ? ORDER BY appointmentDate ASC"
        cursorCal.execute(query, (client_id,))
        appointment_dates = [date[0] for date in cursorCal.fetchall()]

        conn.close()

        field_label_mapping = {
            "clientName": "Ime",
            "clientLastName": "Priimek",
            "clientStreet": "Naslov",
            "clientZIP": "Pošta",
            "clientCity": "Občina",
            "clientDOB": "Datum rojstva",
            "clientEmail": "Email",
            "clientMobile": "Telefon",
            "clientDiagnosis": "Diagnoza"
        }
        self.tableWidget.clear()
        self.tableWidget.setRowCount(len(client_data))
        self.tableWidget.setColumnCount(2)
        self.tableWidget.setColumnWidth(1, 200)
        for row_idx, field_name in enumerate(field_label_mapping.keys()):
            # Use the custom labels for field names
            custom_label = field_label_mapping[field_name]
            field_item = QtWidgets.QTableWidgetItem(custom_label)
            self.tableWidget.setItem(row_idx, 0, field_item)

            # Get the corresponding value from client_data
            field_value = client_data[row_idx]

            value_item = QtWidgets.QTableWidgetItem(str(field_value))
            self.tableWidget.setItem(row_idx, 1, value_item)

        self.amneza.clear()
        self.amneza.setText(str(amneza_value))

        self.report.clear()
        if last_report:
            self.report.setText("Last Report on: " + last_report[0] + "\n" + last_report[1])
        else:
            self.report.setText("No Reports Available")

        # Store the current client info in attributes
        self.currentClientID = client_id
        self.currentClientName = client_data[0]
        self.currentClientLastname = client_data[1]

        if appointment_dates:
            self.calendarWidget.show()
            self.clear_appointment_dates()
            self.mark_appointment_dates(appointment_dates, client_id)
            self.marked_dates = set(appointment_dates)
        else:
            self.calendarWidget.hide()
        self.dateVisit.clear()
        self.numVisits_2.clear()
        if appointment_dates:
            self.dateVisit.setText(str(appointment_dates[0]))
            self.dateVisit.setText(str(appointment_dates[0]))
        else:
            pass
        self.numVisits_2.setText(str(len(appointment_dates)))
    def clear_appointment_dates(self):
        calendar = self.calendarWidget
        empty_format = QtGui.QTextCharFormat()
        for date in self.marked_dates:
            q_date = QtCore.QDate.fromString(date, "yyyy-MM-dd")
            if q_date.isValid():
                calendar.setDateTextFormat(q_date, empty_format)
    def mark_appointment_dates(self, dates_to_mark, client_id):
        calendar = self.calendarWidget
        date_format_str = "yyyy-MM-dd"  # Adjust this to match your date format
        for date in dates_to_mark:
            q_date = QtCore.QDate.fromString(date, date_format_str)
            if q_date.isValid():
                date_format = QtGui.QTextCharFormat()
                # Check if a report_id is present for the current date and client
                if self.check_report_id_for_date_and_client(date, client_id):
                    date_format.setBackground(QtGui.QColor(186, 255, 186))  # Color for dates with a report
                else:
                    date_format.setBackground(QtGui.QColor(255, 0, 0))  # Color for dates without a report
                calendar.setDateTextFormat(q_date, date_format)
    def check_report_id_for_date_and_client(self, date, client_id):
        # Implement the logic to check if a report_id exists for the specified date and client
        conn = sqlite3.connect(path)
        cursor = conn.cursor()
        cursor.execute("SELECT reportID FROM client_report WHERE reportDate = ? AND clientID = ?", (date, client_id))
        report_id = cursor.fetchone()
        conn.close()

        return report_id is not None
    def display_report_for_selected_date(self):
        # Fetch the selected date from the calendar
        date_format_str = "yyyy-MM-dd"
        selected_date = self.calendarWidget.selectedDate()
        # Convert selected_date to a formatted string
        selected_date_str = selected_date.toString(date_format_str)
        # Fetch the report for the selected date from your database
        report_text = self.fetch_report_from_database(selected_date_str, self.currentClientID)
        # Update the reportTextLabel with the retrieved report
        self.report.setText("Izvid z dnem: " + selected_date_str + "\n" + report_text)
    def fetch_report_from_database(self, selected_date, client_id):
        conn = sqlite3.connect(path)
        cursor = conn.cursor()
        cursor.execute("SELECT reportReport FROM client_report WHERE reportDate = ? AND clientID = ?",
                       (selected_date, client_id))
        reportText = cursor.fetchone()
        conn.close()
        # Check if a report was found in the database
        if reportText is not None and len(reportText) > 0:
            return reportText[0]  # Return the first (and only) element of the tuple as a string
        else:
            return "Izvid še ni bil napisan."  # Return an empty string if no report was found

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
